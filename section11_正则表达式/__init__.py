# 正则表达式

# \d    :可以匹配一个数字
# \w    :可以匹配一个字母或数字
# \s    :可以匹配一个空格(也包括TAB等空白符)
# .     :可以匹配任意字符
# *     :表示任意个字符(包括0个)
# +     :表示至少一个字符
# ?     :表示0个或1个字符
# {n}   :表示n个字符
# {n,m} :表示n-m个字符 (注:这里 - 不是运算符号,而是表示 n到m个字符  )
# ^     :表示行的开头 例:  ^\d :表示必须以数字开头
# $     :表示行的结束 例:  \d$ :表示必须以数字结束   ^py$  :表示整行匹配  只能匹配py

# 示例:
# '00\d'        可以匹配 '007',但无法匹配'00A'
# '\d\d\d'      可以匹配 '010'
# '\w\w\d'      可以匹配 'py3'
# 'py.'         可以匹配 'pyc' 、'py0' 、'py!'等等

# 示例:   \d{3}\s+\d{3,8}

# 解读:
# \d{3}     :表示3个数字
# \s+       :表示至少有一个空格
# \d{3,8}   :表示3-8个数字

# 注:如要匹配类似 - 这样的特殊符号,需要使用 \ 进行转义


# 正则表达式高级用法

# []    :表示范围

# 示例:
# [0-9a-zA-Z\_]                 :表示可以匹配一个数字、字符或下划线
# [0-9a-zA-Z\_]+                :表示可以匹配至少一个数字、字符或下划线组成的字符串 例如:'Python'、'0_Z' 或 'Py300'等
# [a-zA-Z\_][0-9a-zA-Z\_]*      :表示可以匹配由字符或下划线开头,后接任意个数字、字符或下划线组成的字符串
# [a-zA-Z\_][0-9a-zA-Z\_]{0,19} :表示可以匹配由字符或下划线开头,后面最多19个有字母、数字或下划线组成的字符串

# A|B   :表示可以匹配A或B

# 示例:
# (P|p)ython    :表示可以匹配 'Python' 或者 'python'


# re模块  :包含所有Python正则表达式的功能
# python本身也用\转义

s = 'ABC\\-001'  # python的字符串
# 对应的正则表达式: 'ABC\-001'

# 当使用了 r 前缀,就不用考虑转义问题 ,例:
s = r'ABC\-001'
# 对应的正则表达式: 'ABC\-001'

# 判断正则表达式是否匹配
import re

# 使用match()方法 如匹配成功,返回一个Match对象 否则返回None
print(re.match(r'^\d{3}\-\d{3,8}$', '010-12345'))  # 输出:<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
print(re.match(r'^\d{3}\-\d{3,8}$', '010 12345'))  # 输出:None

# 常见的正则表达式判断方法:

# test = '用户输入的字符串'
# if re.match(r'正则表达式', test):
#     print('ok')
# else:
#     print('failed')

# ----------------------------------------
# 切分字符串

# 示例:
# 用正则表达式切分连续的空格
print(re.split(r'\s+', 'a b     c'))  # 输出:['a', 'b', 'c']
# 加入 .
print(re.split(r'[\s\,]+', 'a  ,  b  c ,d'))  # 输出:['a', 'b', 'c', 'd']
# 加入 ;
print(re.split(r'[\s\,\;]+', 'a  ,  b  ;c ;,d'))  # 输出:['a', 'b', 'c', 'd']

# ----------------------------------------
# 分组:  用 () 表示的是要提取的分组(Group)

# 示例:
# r(\d{3})\-(\d{3,8})$  :这个正则定义了两个组,分别提取出区号和本地号码
m = re.match(r'(\d{3})-(\d{3,8})$', '010-12345')
print(m)  # 输出:<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
# 如果正则表达式中定义了组  就可以通过group()方法提取出子字符串
# group(0)永远是原始字符串
print(m.group(0))  # 输出:010-12345
print(m.group(1))  # 输出:010
print(m.group(2))  # 输出:12345

t = '10:06:33'
# 这个正则表达式 无法匹配类似 2-30 这样的非法时间
r = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]'
             r'|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
print(r)  # 输出:<_sre.SRE_Match object; span=(0, 8), match='10:06:33'>
print(r.groups())  # 输出:('10', '06', '33')

# ----------------------------------------
# 贪婪模式:尽可能匹配更多的字符
# 注:正则表达式默认是贪婪模式

# 示例:匹配出数字后面的0
r = re.match(r'(\d+)(0*)$', '102300')
print(r)  # 输出:<_sre.SRE_Match object; span=(0, 6), match='102300'>
# 由于 \d+ 采用贪婪模式,直接把后面的0全部匹配了,结果0*只能匹配空字符串了
print(r.groups())  # 输出:('102300', '')

# 解决上述问题,必须采用非贪婪模式(也就是非贪婪模式),才能把后面的0匹配出来
# 解决方法:  加个?就可以让\d+采用非贪婪模式
r = re.match(r'(\d+?)(0*)$', '102300')
print(r)  # 输出:<_sre.SRE_Match object; span=(0, 6), match='102300'>
print(r.groups())  # 输出:('1023', '00')

# ----------------------------------------
# 编译:
# 在python中使用正则表达式,re模块内部会干两件事:
# 1.编译正则表达式,如果正则表达式的字符串本身不合法,会报错
# 2.用编译后的正则表达式去匹配字符串

# 出于效率的考虑,我们可以预编译该正则表达式,接下来使用就不用重复编译该正则表达式了,可以直接匹配:

# 示例:

# 编译
re_telephone = re.compile(r'(\d{3})-(\d{3,8})$')

# 编译后直接生成Regular Expression对象,该对象包含正则表达式,所以调用对应的方法不用再给出正则表达式
# 使用
m = re_telephone.match('010-12345')
print(m)  # 输出:<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
print(m.groups())  # 输出:('010', '12345')

